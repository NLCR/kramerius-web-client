{"version":3,"file":"transform.min.js","sources":["../src/gdaltransform.js","../src/transformer.js"],"sourcesContent":["const HUGE_VAL = Number.POSITIVE_INFINITY\nconst MAXORDER = 3\n\nconst ERRORS = ({\n  MPARMERR: 'PARAMETER ERROR',\n  MINTERR: 'INTERNAL ERROR',\n  MUNSOLVABLE: 'NOT SOLVABLE',\n  MNPTERR: 'NOT ENOUGH POINTS'\n})\n\nexport class GCP {\n  constructor (dfGCPPixel, dfGCPLine, dfGCPX, dfGCPY) {\n    this.dfGCPPixel = dfGCPPixel\n    this.dfGCPLine = dfGCPLine\n    this.dfGCPX = dfGCPX\n    this.dfGCPY = dfGCPY\n  }\n}\n\nclass ControlPoints {\n  // int  count;\n  // double *e1;\n  // double *n1;\n  // double *e2;\n  // double *n2;\n  // int *status;\n}\n\nclass GCPTransformInfo {\n  // double adfToGeoX[20];\n  // double adfToGeoY[20];\n\n  // double adfFromGeoX[20];\n  // double adfFromGeoY[20];\n  // double x1Mean;\n  // double y1Mean;\n  // double x2Mean;\n  // double y2Mean;\n  // int    nOrder;\n  // int    bReversed;\n\n  // int       nGCPCount;\n  // GDAL_GCP *pasGCPList;\n  // int    bRefine;\n  // int    nMinimumGcps;\n  // double dfTolerance;\n\n  // volatile int nRefCount;\n\n  constructor () {\n    this.adfToGeoX = []\n    this.adfToGeoY = []\n\n    this.adfFromGeoX = []\n    this.adfFromGeoY = []\n  }\n}\n\nclass MATRIX {\n  // int     n;     /* SIZE OF THIS MATRIX (N x N) */\n  // double *v;\n\n  constructor (n = 0) {\n    this.n = n\n    this.v = []\n  }\n\n  getM (row, col) {\n    return this.v[(((row) - 1) * (this.n)) + (col) - 1]\n  }\n\n  setM (row, col, value) {\n    this.v[(((row) - 1) * (this.n)) + (col) - 1] = value\n  }\n}\n\nexport function GDALCreateGCPTransformer (pasGCPList, nReqOrder, bReversed) {\n  return GDALCreateGCPTransformerEx(pasGCPList, nReqOrder, bReversed, false, -1, -1)\n}\n\nfunction GDALCreateGCPTransformerEx (pasGCPList, nReqOrder, bReversed, bRefine, dfTolerance, nMinimumGcps) {\n  // double *padfGeoX = nullptr;\n  // double *padfGeoY = nullptr;\n  // double *padfRasterX = nullptr;\n  // double *padfRasterY = nullptr;\n  // int *panStatus = nullptr;\n\n  const nGCPCount = pasGCPList.length\n\n  // let nCRSresult\n  let sPoints = new ControlPoints()\n\n  let x1Sum = 0\n  let y1Sum = 0\n  let x2Sum = 0\n  let y2Sum = 0\n\n  //     memset( &sPoints, 0, sizeof(sPoints) );\n\n  if (nReqOrder === 0) {\n    if (nGCPCount >= 10) {\n      // for now we avoid 3rd order since it is unstable\n      nReqOrder = 2\n    } else if (nGCPCount >= 6) {\n      nReqOrder = 2\n    } else {\n      nReqOrder = 1\n    }\n  }\n\n  const psInfo = new GCPTransformInfo()\n  psInfo.bReversed = bReversed\n  psInfo.nOrder = nReqOrder\n  psInfo.bRefine = bRefine\n  psInfo.dfTolerance = dfTolerance\n  psInfo.nMinimumGcps = nMinimumGcps\n\n  psInfo.nRefCount = 1\n\n  psInfo.pasGCPList = pasGCPList\n  psInfo.nGCPCount = nGCPCount\n\n  // memcpy( psInfo->sTI.abySignature, GDAL_GTI2_SIGNATURE, strlen(GDAL_GTI2_SIGNATURE) );\n  // psInfo->sTI.pszClassName = \"GDALGCPTransformer\";\n  // psInfo->sTI.pfnTransform = GDALGCPTransform;\n  // psInfo->sTI.pfnCleanup = GDALDestroyGCPTransformer;\n  // psInfo->sTI.pfnSerialize = GDALSerializeGCPTransformer;\n  // psInfo->sTI.pfnCreateSimilar = GDALCreateSimilarGCPTransformer;\n\n  /* -------------------------------------------------------------------- */\n  /*      Compute the forward and reverse polynomials.                    */\n  /* -------------------------------------------------------------------- */\n\n  if (nGCPCount === 0) {\n    throw new Error('NOT ENOUGH POINTS')\n  } else if (bRefine) {\n    throw new Error('remove_outliers not implemented')\n    // nCRSresult = remove_outliers(psInfo);\n  } else {\n    /* -------------------------------------------------------------------- */\n    /*      Allocate and initialize the working points list.                */\n    /* -------------------------------------------------------------------- */\n\n    let padfGeoX = []\n    let padfGeoY = []\n    let padfRasterX = []\n    let padfRasterY = []\n    let panStatus = []\n\n    for (let iGCP = 0; iGCP < nGCPCount; iGCP++) {\n      panStatus[iGCP] = 1\n      padfGeoX[iGCP] = pasGCPList[iGCP].dfGCPX\n      padfGeoY[iGCP] = pasGCPList[iGCP].dfGCPY\n      padfRasterX[iGCP] = pasGCPList[iGCP].dfGCPPixel\n      padfRasterY[iGCP] = pasGCPList[iGCP].dfGCPLine\n      x1Sum += pasGCPList[iGCP].dfGCPPixel\n      y1Sum += pasGCPList[iGCP].dfGCPLine\n      x2Sum += pasGCPList[iGCP].dfGCPX\n      y2Sum += pasGCPList[iGCP].dfGCPY\n    }\n\n    psInfo.x1Mean = x1Sum / nGCPCount\n    psInfo.y1Mean = y1Sum / nGCPCount\n    psInfo.x2Mean = x2Sum / nGCPCount\n    psInfo.y2Mean = y2Sum / nGCPCount\n\n    sPoints.count = nGCPCount\n    sPoints.e1 = padfRasterX\n    sPoints.n1 = padfRasterY\n    sPoints.e2 = padfGeoX\n    sPoints.n2 = padfGeoY\n    sPoints.status = panStatus\n\n    crsComputeGeorefEquations(psInfo, sPoints,\n      psInfo.adfToGeoX, psInfo.adfToGeoY,\n      psInfo.adfFromGeoX, psInfo.adfFromGeoY,\n      nReqOrder)\n  }\n\n  return psInfo\n}\n\nfunction crsComputeGeorefEquations (psInfo, cp, E12, N12, E21, N21, order) {\n  // C++ signature:\n  // crsComputeGeorefEquations (GCPTransformInfo *psInfo, struct ControlPoints *cp,\n  //   double E12[], double N12[],\n  //   double E21[], double N21[],\n  //   int order)\n\n  let tempptr\n\n  if (order < 1 || order > MAXORDER) {\n    throw new Error(ERRORS.MPARMERR)\n  }\n\n  /* CALCULATE THE FORWARD TRANSFORMATION COEFFICIENTS */\n  calcCoef(cp, psInfo.x1Mean, psInfo.y1Mean, E12, N12, order)\n\n  /* SWITCH THE 1 AND 2 EASTING AND NORTHING ARRAYS */\n  tempptr = cp.e1\n  cp.e1 = cp.e2\n  cp.e2 = tempptr\n  tempptr = cp.n1\n  cp.n1 = cp.n2\n  cp.n2 = tempptr\n\n  /* CALCULATE THE BACKWARD TRANSFORMATION COEFFICIENTS */\n  calcCoef(cp, psInfo.x2Mean, psInfo.y2Mean, E21, N21, order)\n\n  /* SWITCH THE 1 AND 2 EASTING AND NORTHING ARRAYS BACK */\n  tempptr = cp.e1\n  cp.e1 = cp.e2\n  cp.e2 = tempptr\n  tempptr = cp.n1\n  cp.n1 = cp.n2\n  cp.n2 = tempptr\n}\n\nfunction calcCoef (cp, xMean, yMean, E, N, order) {\n  // C++ signature:\n  // static int\n  // calcCoef (struct ControlPoints *cp, double xMean, double yMean, double E[], double N[], int order)\n\n  const m = new MATRIX()\n\n  const a = []\n  const b = []\n\n  let numactive = 0 /* NUMBER OF ACTIVE CONTROL POINTS */\n  let i = 0\n\n  /* CALCULATE THE NUMBER OF VALID CONTROL POINTS */\n  for (i = numactive = 0; i < cp.count; i++) {\n    if (cp.status[i] > 0) {\n      numactive++\n    }\n  }\n\n  /* CALCULATE THE MINIMUM NUMBER OF CONTROL POINTS NEEDED TO DETERMINE\n    A TRANSFORMATION OF THIS ORDER */\n  m.n = ((order + 1) * (order + 2)) / 2\n\n  if (numactive < m.n) {\n    throw new Error(ERRORS.MNPTERR)\n  }\n\n  m.v = []\n\n  /* INITIALIZE MATRIX */\n  if (numactive === m.n) {\n    exactDet(cp, m, xMean, yMean, a, b, E, N)\n  } else {\n    calcls(cp, m, xMean, yMean, a, b, E, N)\n  }\n}\n\nfunction calcls (cp, m, xMean, yMean, a, b, E, N) {\n  // C++ signature:\n  // static int calcls (\n  //   struct ControlPoints *cp,\n  //   struct MATRIX *m,\n  //   double xMean,\n  //   double yMean,\n  //   double a[],\n  //   double b[],\n  //   double E[],     /* EASTING COEFFICIENTS */\n  //   double N[]     /* NORTHING COEFFICIENTS */\n  // )\n\n  let numactive = 0\n\n  /* INITIALIZE THE UPPER HALF OF THE MATRIX AND THE TWO COLUMN VECTORS */\n\n  for (let i = 1; i <= m.n; i++) {\n    for (let j = i; j <= m.n; j++) {\n      m.setM(i, j, 0)\n    }\n\n    a[i - 1] = b[i - 1] = 0\n  }\n\n  /* SUM THE UPPER HALF OF THE MATRIX AND THE COLUMN VECTORS ACCORDING TO\n     THE LEAST SQUARES METHOD OF SOLVING OVER DETERMINED SYSTEMS */\n\n  for (let n = 0; n < cp.count; n++) {\n    if (cp.status[n] > 0) {\n      numactive++\n\n      for (let i = 1; i <= m.n; i++) {\n        for (let j = i; j <= m.n; j++) {\n          m.setM(i, j, m.getM(i, j) + term(i, cp.e1[n] - xMean, cp.n1[n] - yMean) * term(j, cp.e1[n] - xMean, cp.n1[n] - yMean))\n        }\n\n        a[i - 1] += cp.e2[n] * term(i, cp.e1[n] - xMean, cp.n1[n] - yMean)\n        b[i - 1] += cp.n2[n] * term(i, cp.e1[n] - xMean, cp.n1[n] - yMean)\n      }\n    }\n  }\n\n  if (numactive <= m.n) {\n    throw new Error(ERRORS.MINTERR)\n  }\n\n  /* TRANSPOSE VALUES IN UPPER HALF OF M TO OTHER HALF */\n  for (let i = 2; i <= m.n; i++) {\n    for (let j = 1; j < i; j++) {\n      m.setM(i, j, m.getM(j, i))\n    }\n  }\n\n  return solveMat(m, a, b, E, N)\n}\n\nfunction exactDet (cp, m, xMean, yMean, a, b, E, N) {\n  // C++ signature:\n  // static int exactDet (\n  //   struct ControlPoints *cp,\n  //   struct MATRIX *m,\n  //   double xMean,\n  //   double yMean,\n  //   double a[],\n  //   double b[],\n  //   double E[],     /* EASTING COEFFICIENTS */\n  //   double N[]     /* NORTHING COEFFICIENTS */\n  // )\n  let currow = 1\n\n  for (let pntnow = 0; pntnow < cp.count; pntnow++) {\n    if (cp.status[pntnow] > 0) {\n      /* POPULATE MATRIX M */\n      for (let j = 1; j <= m.n; j++) {\n        m.setM(currow, j, term(j, cp.e1[pntnow] - xMean, cp.n1[pntnow] - yMean))\n      }\n\n      /* POPULATE MATRIX A AND B */\n      a[currow - 1] = cp.e2[pntnow]\n      b[currow - 1] = cp.n2[pntnow]\n\n      currow++\n    }\n  }\n\n  if (currow - 1 !== m.n) {\n    throw new Error(ERRORS.MINTERR)\n  }\n\n  return solveMat(m, a, b, E, N)\n}\n\nfunction solveMat (m, a, b, E, N) {\n  // C++ signature:\n  // static int solveMat (struct MATRIX *m,\n  //   double a[], double b[], double E[], double N[])\n\n  for (let i = 1; i <= m.n; i++) {\n    let j = i\n\n    /* find row with largest magnitude value for pivot value */\n    let pivot = m.getM(i, j) /* ACTUAL VALUE OF THE LARGEST PIVOT CANDIDATE */\n    let imark = i\n\n    for (let i2 = i + 1; i2 <= m.n; i2++) {\n      if (Math.abs(m.getM(i2, j)) > Math.abs(pivot)) {\n        pivot = m.getM(i2, j)\n        imark = i2\n      }\n    }\n\n    /* if the pivot is very small then the points are nearly co-linear */\n    /* co-linear points result in an undefined matrix, and nearly */\n    /* co-linear points results in a solution with rounding error */\n\n    if (pivot === 0.0) {\n      throw new Error(ERRORS.MUNSOLVABLE)\n    }\n\n    /* if row with highest pivot is not the current row, switch them */\n    if (imark !== i) {\n      for (let j2 = 1; j2 <= m.n; j2++) {\n        // std::swap(M(imark,j2), M(i,j2));\n        const M1 = m.getM(imark, j2)\n        const M2 = m.getM(i, j2)\n\n        m.setM(imark, j2, M2)\n        m.setM(i, j2, M1)\n      }\n\n      // std::swap(a[imark-1], a[i-1]);\n      // std::swap(b[imark-1], b[i-1]);\n      const ta1 = a[imark - 1]\n      const ta2 = a[i - 1]\n      a[i - 1] = ta1\n      a[imark - 1] = ta2\n\n      const tb1 = b[imark - 1]\n      const tb2 = b[i - 1]\n      b[imark - 1] = tb2\n      b[i - 1] = tb1\n    }\n\n    /* compute zeros above and below the pivot, and compute\n       values for the rest of the row as well */\n    for (let i2 = 1 ; i2 <= m.n; i2++) {\n      if (i2 !== i) {\n        const factor = m.getM(i2, j) / pivot\n\n        for (let j2 = j; j2 <= m.n; j2++) {\n          const d = factor * m.getM(i, j2)\n          m.setM(i2, j2, m.getM(i2, j2) - d)\n        }\n\n        a[i2 - 1] -= factor * a[i - 1]\n        b[i2 - 1] -= factor * b[i - 1]\n      }\n    }\n  }\n\n  /* SINCE ALL OTHER VALUES IN THE MATRIX ARE ZERO NOW, CALCULATE THE\n    COEFFICIENTS BY DIVIDING THE COLUMN VECTORS BY THE DIAGONAL VALUES. */\n  for (let i = 1; i <= m.n; i++) {\n    E[i - 1] = a[i - 1] / m.getM(i, i)\n    N[i - 1] = b[i - 1] / m.getM(i, i)\n  }\n}\n\nfunction term (nTerm, e, n) {\n  switch (nTerm) {\n    case 1:\n      return 1\n    case 2:\n      return e\n    case 3:\n      return n\n    case 4:\n      return e * e\n    case 5:\n      return e * n\n    case 6:\n      return n * n\n    case 7:\n      return e * e * e\n    case 8:\n      return e * e * n\n    case 9:\n      return e * n * n\n    case 10:\n      return n * n * n\n  }\n\n  return 0\n}\n\nexport function GDALGCPTransform (pTransformArg, bDstToSrc, points) {\n  const nPointCount = points.length\n\n  // GCPTransformInfo *psInfo = static_cast<GCPTransformInfo *>(pTransformArg);\n  const psInfo = pTransformArg\n\n  const transformedPoints = []\n\n  if (psInfo.bReversed) {\n    bDstToSrc = !bDstToSrc\n  }\n\n  for (let i = 0; i < nPointCount; i++) {\n    if (points[i].x === HUGE_VAL || points[i].y === HUGE_VAL) {\n      throw new Error('HUGE_VAL')\n    }\n\n    let transformedPoint\n\n    if (bDstToSrc) {\n      transformedPoint = crsGeoref(\n        points[i].x - psInfo.x2Mean, points[i].y - psInfo.y2Mean,\n        psInfo.adfFromGeoX, psInfo.adfFromGeoY,\n        psInfo.nOrder)\n    } else {\n      transformedPoint = crsGeoref(\n        points[i].x - psInfo.x1Mean, points[i].y - psInfo.y1Mean,\n        psInfo.adfToGeoX, psInfo.adfToGeoY,\n        psInfo.nOrder)\n    }\n\n    transformedPoints[i] = {\n      x: transformedPoint[0],\n      y: transformedPoint[1]\n    }\n  }\n\n  return transformedPoints\n}\n\nfunction crsGeoref (e1, n1, E, N, order) {\n  // C++ signature:\n  // static int crsGeoref (\n  //   double e1,  /* EASTINGS TO BE TRANSFORMED */\n  //   double n1,  /* NORTHINGS TO BE TRANSFORMED */\n  //   double *e,  /* EASTINGS TO BE TRANSFORMED */\n  //   double *n,  /* NORTHINGS TO BE TRANSFORMED */\n  //   double E[], /* EASTING COEFFICIENTS */\n  //   double N[], /* NORTHING COEFFICIENTS */\n  //   int order  /* ORDER OF TRANSFORMATION TO BE PERFORMED, MUST MATCH THE\n  //                ORDER USED TO CALCULATE THE COEFFICIENTS */\n  // )\n\n  let e3 = 0\n  let e2n = 0\n  let en2 = 0\n  let n3 = 0\n  let e2 = 0\n  let en = 0\n  let n2 = 0\n\n  let e\n  let n\n\n  if (order === 1) {\n    e = E[0] + E[1] * e1 + E[2] * n1\n    n = N[0] + N[1] * e1 + N[2] * n1\n\n    return [e, n]\n  } else if (order === 2) {\n    e2 = e1 * e1\n    n2 = n1 * n1\n    en = e1 * n1\n\n    e = E[0]      + E[1] * e1 + E[2] * n1 +\n        E[3] * e2 + E[4] * en + E[5] * n2\n\n    n = N[0]      + N[1] * e1 + N[2] * n1 +\n        N[3] * e2 + N[4] * en + N[5] * n2\n\n    return [e, n]\n  } else if (order === 3) {\n    e2  = e1 * e1\n    en  = e1 * n1\n    n2  = n1 * n1\n    e3  = e1 * e2\n    e2n = e2 * n1\n    en2 = e1 * n2\n    n3  = n1 * n2\n\n    e = E[0]      +\n        E[1] * e1 + E[2] * n1  +\n        E[3] * e2 + E[4] * en  + E[5] * n2  +\n        E[6] * e3 + E[7] * e2n + E[8] * en2 + E[9] * n3\n    n = N[0]      +\n        N[1] * e1 + N[2] * n1  +\n        N[3] * e2 + N[4] * en  + N[5] * n2  +\n        N[6] * e3 + N[7] * e2n + N[8] * en2 + N[9] * n3\n\n    return [e, n]\n  } else {\n    throw new Error(ERRORS.MPARMERR)\n  }\n}\n","import {GCP, GDALCreateGCPTransformer, GDALGCPTransform} from './gdaltransform.js'\n\nexport function toWorld (transformArgs, point) {\n  const bInverse = false\n\n  const input = [{x: point[0], y: point[1]}]\n  const output = GDALGCPTransform(transformArgs, bInverse, input)\n\n  return [output[0].y, output[0].x]\n}\n\nexport function toImage (transformArgs, point) {\n  const bInverse = true\n\n  const input = [({x: point[1], y: point[0]})]\n  const output = GDALGCPTransform(transformArgs, bInverse, input)\n\n  return [output[0].x, output[0].y]\n}\n\nexport function createTransformer (gcps) {\n  const pasGCPs = gcps\n    .map((gcp) => new GCP(\n      gcp.image[0], gcp.image[1],\n      gcp.world[1], gcp.world[0]\n    ))\n\n  const nOrder = 0\n  return GDALCreateGCPTransformer(pasGCPs, nOrder, false)\n}\n"],"names":["HUGE_VAL","Number","POSITIVE_INFINITY","ERRORS","GCP","constructor","dfGCPPixel","dfGCPLine","dfGCPX","dfGCPY","ControlPoints","GCPTransformInfo","adfToGeoX","adfToGeoY","adfFromGeoX","adfFromGeoY","MATRIX","n","v","getM","row","col","this","setM","value","GDALCreateGCPTransformer","pasGCPList","nReqOrder","bReversed","bRefine","dfTolerance","nMinimumGcps","nGCPCount","length","sPoints","x1Sum","y1Sum","x2Sum","y2Sum","psInfo","nOrder","nRefCount","Error","padfGeoX","padfGeoY","padfRasterX","padfRasterY","panStatus","iGCP","x1Mean","y1Mean","x2Mean","y2Mean","count","e1","n1","e2","n2","status","cp","E12","N12","E21","N21","order","tempptr","calcCoef","crsComputeGeorefEquations","GDALCreateGCPTransformerEx","xMean","yMean","E","N","m","a","b","numactive","i","currow","pntnow","j","term","solveMat","exactDet","calcls","pivot","imark","i2","Math","abs","j2","M1","M2","ta1","ta2","tb1","tb2","factor","d","nTerm","e","GDALGCPTransform","pTransformArg","bDstToSrc","points","nPointCount","transformedPoints","x","y","transformedPoint","crsGeoref","e3","e2n","en2","n3","en","gcps","map","gcp","image","world","transformArgs","point","output"],"mappings":"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"}